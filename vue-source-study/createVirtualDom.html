<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>

  <body>
    <div id="root">
      <div>
        <div title="1" class="a">hello1</div>
        <div title="2">hello2</div>
        <div title="3">hello3</div>
        <ul>
          <li>1</li>
          <li>2</li>
          <li>3</li>
        </ul>
      </div>
    </div>
  </body>
</html>

<script>
  // 虚拟Dom -> 性能
  // <div /> => {tag: "div  "}
  // 文本节点 => { tag: undefined, value: "文本"}
  // <div title="1" class="c" />  => {tag: "div", data: {title: "1", class:"c"}}
  // <div><div />div> =>{tag: "div",children: [{tag: "div"}]}

  class Vnode {
    constructor(tag, data, value, type) {
      this.tag = tag && tag.toLowerCase();
      this.data = data;
      this.value = value;
      this.type = type;
      this.children = [];
    }
    appendChild(vnode) {
      this.children.push(vnode);
    }
  }

  // Vue中源码使用栈结构，使用栈结构存储父节点来实现递归生成virtualDom
  // 真实dom转换成虚拟dom
  function getVNode(node) {
    let nodeType = node.nodeType;
    let _vnode = null;
    if (nodeType === 1) {
      let nodeName = node.nodeName;
      let attrs = node.attributes; // 伪数组
      let _attrObj = {};
      for (let i = 0; i < attrs.length; i++) {
        _attrObj[attrs[i].nodeName] = attrs[i].nodeValue;
      }
      _vnode = new Vnode(nodeName, _attrObj, undefined, nodeType);

      let childNodes = node.childNodes;
      for (let j = 0; j < childNodes.length; j++) {
        _vnode.appendChild(getVNode(childNodes[j]));
      }
    } else if (nodeType === 3) {
      _vnode = new Vnode(undefined, undefined, node.nodeValue, nodeType);
    }

    return _vnode;
  }

  // 虚拟DOM转换成虚拟DOM

  function parseVNode(vnode) {
    let nodeType = vnode.type;
    let _node = null;
     if (nodeType === 1) {
      _node = document.createElement(vnode.tag)
      let data = vnode.data;
      Object.keys(data).forEach((key) => {
        let attrName = key;
        let attrValue = data[key];
        _node.setAttribute(attrName, attrValue);
      });

      let children = vnode.children;
      children.forEach((subvnode) => {
        _node.appendChild(parseVNode(subvnode));
      });
    }else if (nodeType === 3) {
      _node = document.createTextNode(vnode.value);
    }
    return _node
  }

  let root = document.querySelector("#root");
  let vnode = getVNode(root)
  console.log(vnode);
  let realDom = parseVNode(vnode)
  console.log(realDom);

  // 柯里化： 函数本来有多个参数，只传入一个参数，生成一个新函数，新函数接收剩下的参数来运行得到结果；
  // 偏函数: 函数本来有多个参数，接受 一部分参数，生成一个新函数，新函数接收剩下的参数运行得到结果；
  // 高阶函数：函数的参数是一个函数，该函数对参数函数进行加工，得到一个函数，加工的这个函数就是高阶函数；
 
  // 为什么用柯里化：缓存一部分数据，提升性能
 
  // Vue 本质上是使用 HTML的字符串作为模板，将字符串转换成AST，再转换为Vnode.
  /*
    1. 模板-> AST；
    2. AST-> VNode;
    3. VNode -> DOM
  */

  /*
    let a = 1+2*(3+4*4)*(6+7)
    一般会转换成“波兰式”表达式，然后使用栈结构来计算；（波兰式，逆波兰式与表达式求值）
  */
</script>
